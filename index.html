<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>forecast-model-vis</title>

<link rel="icon" href="data:,">

<link href="https://cdn.jsdelivr.net/npm/maplibre-gl@3.6.1/dist/maplibre-gl.css" rel="stylesheet" />
<script src="https://cdn.jsdelivr.net/npm/maplibre-gl@3.6.1/dist/maplibre-gl.js"></script>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<style>
body { margin:0; background:#0f0f0f; color:#ddd; font-family:system-ui; }
#map { width:100vw; height:100vh; }

#panel {
  position:absolute; top:20px; right:20px;
  width:460px; max-height:90vh;
  overflow-y:auto;
  background:rgba(20,20,20,0.96);
  padding:16px; border-radius:8px;
}

label { display:block; margin-top:6px; }
canvas { margin-top:20px; }
</style>
</head>
<body>

<div id="map"></div>

<div id="panel">
<h2>forecast-model-vis</h2>

<strong>Select Models</strong>
<label><input type="checkbox" value="gfs" checked> GFS</label>
<label><input type="checkbox" value="icon"> ICON</label>
<label><input type="checkbox" value="ukmo"> UKMO</label>
<label><input type="checkbox" value="meteofrance"> MeteoFrance</label>
<label><input type="checkbox" value="ecmwf"> ECMWF</label>

<br>

<strong>Variable</strong>
<select id="variableSelect">
  <option value="temperature_2m">Temperature (Â°C)</option>
  <option value="precipitation">Precipitation (mm)</option>
</select>

<strong>Comparison Mode</strong>
<select id="modeSelect">
  <option value="overlay">Overlay</option>
  <option value="spread">Spread Envelope</option>
</select>

<div id="content" style="margin-top:10px;">
Click on map.
</div>

<canvas id="chart"></canvas>
</div>

<script>

/* ================= MAP ================= */
const map = new maplibregl.Map({
  container:'map',
  style:'https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json',
  center:[12,50],
  zoom:4
});
map.addControl(new maplibregl.NavigationControl());

let lastLat=null;
let lastLon=null;
let chart=null;

const modelColors={
  gfs:"#ff6b6b",
  icon:"#4dabf7",
  ukmo:"#ffd43b",
  meteofrance:"#69db7c",
  ecmwf:"#b197fc"
};

/* ================= EVENT HANDLERS ================= */
map.on('click',(e)=>{
  lastLat=e.lngLat.lat;
  lastLon=e.lngLat.lng;
  fetchAll();
});

document.querySelectorAll("input[type=checkbox], #variableSelect, #modeSelect")
  .forEach(el=>el.addEventListener("change",()=>{ if(lastLat) fetchAll(); }));

/* ================= FETCH ================= */
async function fetchAll(){

  const variable=document.getElementById("variableSelect").value;
  const mode=document.getElementById("modeSelect").value;

  const selected=Array.from(
    document.querySelectorAll("input[type=checkbox]:checked")
  ).map(cb=>cb.value);

  if(selected.length===0){
    document.getElementById("content").innerHTML="Select at least one model.";
    return;
  }

  document.getElementById("content").innerHTML="Loading...";

  const results=(await Promise.all(
    selected.map(m=>fetchModel(m,variable))
  )).filter(r=>r!==null);

  if(results.length===0){
    document.getElementById("content").innerHTML="No valid data.";
    return;
  }

  renderChart(results,variable,mode);
}

/* ================= SINGLE MODEL ================= */
async function fetchModel(modelKey,variable){

  let url;

  if(modelKey==="ecmwf"){
    url=`https://api.open-meteo.com/v1/ecmwf?latitude=${lastLat}&longitude=${lastLon}&hourly=${variable}&timezone=UTC`;
  }else{
    url=`https://api.open-meteo.com/v1/forecast?latitude=${lastLat}&longitude=${lastLon}&hourly=${variable}&model=${modelKey}&timezone=UTC`;
  }

  try{
    const r=await fetch(url);
    if(!r.ok) return null;
    const d=await r.json();

    return {
      model:modelKey,
      times:d.hourly.time.map(t=>new Date(t).toISOString()),
      values:d.hourly[variable]
    };

  }catch{ return null; }
}

/* ================= TIME ALIGNMENT ================= */
function alignModels(models){

  // restrict to overlapping time window
  const minEnd=Math.min(...models.map(m=>m.times.length));
  models.forEach(m=>{
    m.times=m.times.slice(0,minEnd);
    m.values=m.values.slice(0,minEnd);
  });

  return models;
}

/* ================= RENDER ================= */
function renderChart(models,variable,mode){

  models=alignModels(models);

  const labels=models[0].times.map(t=>{
    const d=new Date(t);
    return d.toLocaleString(undefined,{
      weekday:'short',
      hour:'2-digit'
    });
  });

  if(chart) chart.destroy();

  const ctx=document.getElementById("chart").getContext("2d");

  if(mode==="overlay"){

    const datasets=models.map(m=>({
      label:m.model.toUpperCase(),
      data:m.values,
      borderColor:modelColors[m.model],
      tension:0.3,
      pointRadius:0,
      fill:false
    }));

    chart=new Chart(ctx,{
      type:'line',
      data:{ labels,datasets },
      options:chartOptions()
    });

  }else{

    // Spread mode
    const matrix=models.map(m=>m.values);

    const minVals=matrix[0].map((_,i)=>Math.min(...matrix.map(row=>row[i])));
    const maxVals=matrix[0].map((_,i)=>Math.max(...matrix.map(row=>row[i])));

    chart=new Chart(ctx,{
      type:'line',
      data:{
        labels,
        datasets:[
          {
            label:"Max",
            data:maxVals,
            borderColor:"#999",
            fill:false
          },
          {
            label:"Min",
            data:minVals,
            borderColor:"#999",
            fill:"-1",
            backgroundColor:"rgba(150,150,150,0.2)"
          }
        ]
      },
      options:chartOptions()
    });
  }

  document.getElementById("content").innerHTML=`
    <strong>Location:</strong><br>
    ${lastLat.toFixed(2)}, ${lastLon.toFixed(2)}<br>
    ${models.length} model(s)
  `;
}

/* ================= CHART OPTIONS ================= */
function chartOptions(){
  return{
    responsive:true,
    scales:{
      x:{ ticks:{ color:'#aaa', maxTicksLimit:8 }},
      y:{ ticks:{ color:'#aaa' }}
    },
    plugins:{
      legend:{ labels:{ color:'#ddd' }}
    }
  };
}

</script>
</body>
</html>
