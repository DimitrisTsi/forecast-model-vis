<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>forecast-model-vis</title>

<link rel="icon" href="data:,">

<link href="https://cdn.jsdelivr.net/npm/maplibre-gl@3.6.1/dist/maplibre-gl.css" rel="stylesheet" />
<script src="https://cdn.jsdelivr.net/npm/maplibre-gl@3.6.1/dist/maplibre-gl.js"></script>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<style>
body { margin:0; background:#0f0f0f; color:#ddd; font-family:system-ui; }
#map { width:100vw; height:100vh; }

#panel {
  position:absolute; top:20px; right:20px;
  width:440px; max-height:90vh;
  overflow-y:auto;
  background:rgba(20,20,20,0.96);
  padding:16px; border-radius:8px;
}

label { display:block; margin-top:6px; }
canvas { margin-top:20px; }
</style>
</head>
<body>

<div id="map"></div>

<div id="panel">
<h2>forecast-model-vis</h2>

<strong>Select Models</strong>
<label><input type="checkbox" value="gfs" checked> GFS</label>
<label><input type="checkbox" value="icon"> ICON</label>
<label><input type="checkbox" value="ukmo"> UKMO</label>
<label><input type="checkbox" value="meteofrance"> MeteoFrance</label>
<label><input type="checkbox" value="ecmwf"> ECMWF</label>

<br>

<strong>Variable</strong>
<select id="variableSelect">
  <option value="temperature_2m">Temperature (Â°C)</option>
  <option value="precipitation">Precipitation (mm)</option>
</select>

<div id="content" style="margin-top:10px;">
Click on map.
</div>

<canvas id="chart"></canvas>
</div>

<script>

/* ================= MAP ================= */
const map = new maplibregl.Map({
  container:'map',
  style:'https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json',
  center:[12,50],
  zoom:4
});

map.addControl(new maplibregl.NavigationControl());

let lastLat=null;
let lastLon=null;
let chart=null;

const modelColors={
  gfs:"#ff6b6b",
  icon:"#4dabf7",
  ukmo:"#ffd43b",
  meteofrance:"#69db7c",
  ecmwf:"#b197fc"
};

map.on('click',(e)=>{
  lastLat=e.lngLat.lat;
  lastLon=e.lngLat.lng;
  fetchAll();
});

document.getElementById("variableSelect")
  .addEventListener("change",()=>{ if(lastLat) fetchAll(); });

document.querySelectorAll("input[type=checkbox]")
  .forEach(cb=>cb.addEventListener("change",()=>{ if(lastLat) fetchAll(); }));

/* ================= FETCH ================= */

async function fetchAll(){

  const variable=document.getElementById("variableSelect").value;

  const selected=Array.from(
    document.querySelectorAll("input[type=checkbox]:checked")
  ).map(cb=>cb.value);

  if(selected.length===0){
    document.getElementById("content").innerHTML="Select at least one model.";
    return;
  }

  document.getElementById("content").innerHTML="Loading...";

  const promises=selected.map(m=>fetchModel(m,variable));
  const results=(await Promise.all(promises)).filter(r=>r!==null);

  if(results.length===0){
    document.getElementById("content").innerHTML="No valid data.";
    return;
  }

  renderChart(results,variable);
}

/* ================= SINGLE MODEL ================= */

async function fetchModel(modelKey,variable){

  let url;

  if(modelKey==="ecmwf"){
    url=`https://api.open-meteo.com/v1/ecmwf?latitude=${lastLat}&longitude=${lastLon}&hourly=${variable}&timezone=auto`;
  }else{
    url=`https://api.open-meteo.com/v1/forecast?latitude=${lastLat}&longitude=${lastLon}&hourly=${variable}&model=${modelKey}&timezone=auto`;
  }

  try{
    const r=await fetch(url);
    if(!r.ok) return null;
    const d=await r.json();

    return {
      model:modelKey,
      times:d.hourly.time.slice(0,48),
      values:d.hourly[variable].slice(0,48)
    };

  }catch{ return null; }
}

/* ================= ALIGN TIME ================= */

function buildUnifiedTimeAxis(models){

  const allTimes=new Set();

  models.forEach(m=>{
    m.times.forEach(t=>allTimes.add(t));
  });

  return Array.from(allTimes).sort();
}

function alignModelData(unifiedTimes,model){

  const mapObj={};
  model.times.forEach((t,i)=>{ mapObj[t]=model.values[i]; });

  return unifiedTimes.map(t=> mapObj[t] ?? null );
}

/* ================= RENDER ================= */

function renderChart(models,variable){

  const unifiedTimes=buildUnifiedTimeAxis(models);

  const formattedLabels=unifiedTimes.map(t=>{
    const d=new Date(t);
    return d.toLocaleString(undefined,{
      day:'2-digit',
      hour:'2-digit'
    });
  });

  if(chart) chart.destroy();

  const ctx=document.getElementById("chart").getContext("2d");

  const datasets=models.map(m=>({
    label:m.model.toUpperCase(),
    data:alignModelData(unifiedTimes,m),
    borderColor:modelColors[m.model],
    tension:0.3,
    pointRadius:0,
    fill:false
  }));

  chart=new Chart(ctx,{
    type:'line',
    data:{
      labels:formattedLabels,
      datasets:datasets
    },
    options:{
      responsive:true,
      scales:{
        x:{
          ticks:{ color:'#aaa', maxTicksLimit:8 }
        },
        y:{
          ticks:{ color:'#aaa' }
        }
      },
      plugins:{
        legend:{
          labels:{ color:'#ddd' }
        }
      }
    }
  });

  document.getElementById("content").innerHTML=`
    <strong>Location:</strong><br>
    ${lastLat.toFixed(2)}, ${lastLon.toFixed(2)}<br>
    Comparing ${models.length} model(s)
  `;
}

</script>
</body>
</html>
